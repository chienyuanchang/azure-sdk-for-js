## API Report File for "@azure-rest/ai-content-understanding"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AbortSignalLike } from '@azure/abort-controller';
import { ClientOptions } from '@azure-rest/core-client';
import { ErrorModel } from '@azure-rest/core-client';
import { KeyCredential } from '@azure/core-auth';
import { OperationOptions } from '@azure-rest/core-client';
import { OperationState as OperationState_2 } from '@azure/core-lro';
import { PathUncheckedResponse } from '@azure-rest/core-client';
import { Pipeline } from '@azure/core-rest-pipeline';
import { PollerLike } from '@azure/core-lro';
import { TokenCredential } from '@azure/core-auth';

// @public
export interface AnalyzeInput {
    data?: Uint8Array;
    mimeType?: string;
    name?: string;
    range?: string;
    url?: string;
}

// @public
export interface AnalyzeResult {
    analyzerId?: string;
    apiVersion?: string;
    contents: MediaContentUnion[];
    createdAt?: Date;
    stringEncoding?: StringEncoding;
    warnings?: ErrorModel[];
}

// @public
export type AnnotationFormat = "none" | "markdown";

// @public
export interface ArrayField extends ContentField {
    type: "array";
    valueArray?: ContentFieldUnion[];
}

// @public
export interface AudioVisualContent extends MediaContent {
    cameraShotTimesMs?: number[];
    endTimeMs: number;
    height?: number;
    keyFrameTimesMs?: number[];
    kind: "audioVisual";
    segments?: AudioVisualContentSegment[];
    startTimeMs: number;
    transcriptPhrases?: TranscriptPhrase[];
    width?: number;
}

// @public
export interface AudioVisualContentSegment {
    category: string;
    endTimeMs: number;
    segmentId: string;
    span: ContentSpan;
    startTimeMs: number;
}

// @public
export interface BooleanField extends ContentField {
    type: "boolean";
    valueBoolean?: boolean;
}

// @public
export type ChartFormat = "chartJs" | "markdown";

// @public
export interface ContentAnalyzer {
    readonly analyzerId: string;
    baseAnalyzerId?: string;
    config?: ContentAnalyzerConfig;
    readonly createdAt: Date;
    description?: string;
    dynamicFieldSchema?: boolean;
    fieldSchema?: ContentFieldSchema;
    knowledgeSources?: KnowledgeSourceUnion[];
    readonly lastModifiedAt: Date;
    models?: Record<string, string>;
    processingLocation?: ProcessingLocation;
    readonly status: ResourceStatus;
    readonly supportedModels?: SupportedModels;
    tags?: Record<string, string>;
    readonly warnings?: ErrorModel[];
}

// @public
export interface ContentAnalyzerAnalyzeOperationStatus {
    error?: ErrorModel;
    id: string;
    result?: AnalyzeResult;
    status: OperationState;
    usage?: UsageDetails;
}

// @public
export interface ContentAnalyzerConfig {
    annotationFormat?: AnnotationFormat;
    chartFormat?: ChartFormat;
    contentCategories?: Record<string, ContentCategoryDefinition>;
    disableFaceBlurring?: boolean;
    enableAnnotation?: boolean;
    enableFigureAnalysis?: boolean;
    enableFigureDescription?: boolean;
    enableFormula?: boolean;
    enableLayout?: boolean;
    enableOcr?: boolean;
    enableSegment?: boolean;
    estimateFieldSourceAndConfidence?: boolean;
    locales?: string[];
    omitContent?: boolean;
    returnDetails?: boolean;
    segmentPerPage?: boolean;
    tableFormat?: TableFormat;
}

// @public
export interface ContentAnalyzerOperationStatus {
    error?: ErrorModel;
    id: string;
    result?: ContentAnalyzer;
    status: OperationState;
    usage?: UsageDetails;
}

// @public
export interface ContentAnalyzersAnalyzeBinaryOptionalParams extends OperationOptions {
    clientRequestId?: string;
    processingLocation?: ProcessingLocation;
    range?: string;
    stringEncoding?: StringEncoding;
    updateIntervalInMs?: number;
}

// @public
export interface ContentAnalyzersAnalyzeOptionalParams extends OperationOptions {
    clientRequestId?: string;
    inputs?: AnalyzeInput[];
    modelDeployments?: Record<string, string>;
    processingLocation?: ProcessingLocation;
    stringEncoding?: StringEncoding;
    updateIntervalInMs?: number;
}

// @public
export interface ContentAnalyzersCopyOptionalParams extends OperationOptions {
    allowReplace?: boolean;
    clientRequestId?: string;
    sourceAzureResourceId?: string;
    sourceRegion?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ContentAnalyzersCreateOrReplaceOptionalParams extends OperationOptions {
    allowReplace?: boolean;
    clientRequestId?: string;
    updateIntervalInMs?: number;
}

// @public
export interface ContentAnalyzersDeleteOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface ContentAnalyzersDeleteResultOptionalParams extends OperationOptions {
}

// @public
export interface ContentAnalyzersGetDefaultsOptionalParams extends OperationOptions {
}

// @public
export interface ContentAnalyzersGetOperationStatusOptionalParams extends OperationOptions {
}

// @public
export interface ContentAnalyzersGetOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface ContentAnalyzersGetResultFileOptionalParams extends OperationOptions {
}

// @public
export interface ContentAnalyzersGetResultOptionalParams extends OperationOptions {
}

// @public
export interface ContentAnalyzersGrantCopyAuthorizationOptionalParams extends OperationOptions {
    clientRequestId?: string;
    targetRegion?: string;
}

// @public
export interface ContentAnalyzersListOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface ContentAnalyzersOperations {
    analyze: (analyzerId: string, options?: ContentAnalyzersAnalyzeOptionalParams) => PollerLike<OperationState_2<AnalyzeResult>, AnalyzeResult>;
    analyzeBinary: (analyzerId: string, contentType: string, input: Uint8Array, options?: ContentAnalyzersAnalyzeBinaryOptionalParams) => PollerLike<OperationState_2<AnalyzeResult>, AnalyzeResult>;
    copy: (analyzerId: string, sourceAnalyzerId: string, options?: ContentAnalyzersCopyOptionalParams) => PollerLike<OperationState_2<ContentAnalyzer>, ContentAnalyzer>;
    createOrReplace: (analyzerId: string, resource: ContentAnalyzer, options?: ContentAnalyzersCreateOrReplaceOptionalParams) => PollerLike<OperationState_2<ContentAnalyzer>, ContentAnalyzer>;
    delete: (analyzerId: string, options?: ContentAnalyzersDeleteOptionalParams) => Promise<void>;
    deleteResult: (operationId: string, options?: ContentAnalyzersDeleteResultOptionalParams) => Promise<void>;
    get: (analyzerId: string, options?: ContentAnalyzersGetOptionalParams) => Promise<ContentAnalyzer>;
    getDefaults: (options?: ContentAnalyzersGetDefaultsOptionalParams) => Promise<ContentUnderstandingDefaults>;
    getOperationStatus: (analyzerId: string, operationId: string, options?: ContentAnalyzersGetOperationStatusOptionalParams) => Promise<ContentAnalyzerOperationStatus>;
    getResult: (operationId: string, options?: ContentAnalyzersGetResultOptionalParams) => Promise<ContentAnalyzerAnalyzeOperationStatus>;
    getResultFile: (operationId: string, path: string, options?: ContentAnalyzersGetResultFileOptionalParams) => Promise<Uint8Array>;
    grantCopyAuthorization: (analyzerId: string, targetAzureResourceId: string, options?: ContentAnalyzersGrantCopyAuthorizationOptionalParams) => Promise<CopyAuthorization>;
    list: (options?: ContentAnalyzersListOptionalParams) => PagedAsyncIterableIterator<ContentAnalyzer>;
    update: (analyzerId: string, resource: ContentAnalyzer, options?: ContentAnalyzersUpdateOptionalParams) => Promise<ContentAnalyzer>;
    updateDefaults: (options?: ContentAnalyzersUpdateDefaultsOptionalParams) => Promise<ContentUnderstandingDefaults>;
}

// @public
export interface ContentAnalyzersUpdateDefaultsOptionalParams extends OperationOptions {
    modelDeployments?: Record<string, string>;
}

// @public
export interface ContentAnalyzersUpdateOptionalParams extends OperationOptions {
    clientRequestId?: string;
}

// @public
export interface ContentCategoryDefinition {
    analyzer?: ContentAnalyzer;
    analyzerId?: string;
    description?: string;
}

// @public
export interface ContentField {
    confidence?: number;
    source?: string;
    spans?: ContentSpan[];
    type: ContentFieldType;
}

// @public
export interface ContentFieldDefinition {
    description?: string;
    enum?: string[];
    enumDescriptions?: Record<string, string>;
    estimateSourceAndConfidence?: boolean;
    examples?: string[];
    items?: ContentFieldDefinition;
    method?: GenerationMethod;
    properties?: Record<string, ContentFieldDefinition>;
    ref?: string;
    type?: ContentFieldType;
}

// @public
export interface ContentFieldSchema {
    definitions?: Record<string, ContentFieldDefinition>;
    description?: string;
    fields: Record<string, ContentFieldDefinition>;
    name?: string;
}

// @public
export type ContentFieldType = "string" | "date" | "time" | "number" | "integer" | "boolean" | "array" | "object" | "json";

// @public
export type ContentFieldUnion = StringField | DateField | TimeField | NumberField | IntegerField | BooleanField | ArrayField | ObjectField | JsonField | ContentField;

// @public
export interface ContentSpan {
    length: number;
    offset: number;
}

// @public (undocumented)
export class ContentUnderstandingClient {
    constructor(endpointParam: string, credential: KeyCredential | TokenCredential, options?: ContentUnderstandingClientOptionalParams);
    readonly contentAnalyzers: ContentAnalyzersOperations;
    readonly pipeline: Pipeline;
}

// @public
export interface ContentUnderstandingClientOptionalParams extends ClientOptions {
    apiVersion?: string;
}

// @public
export interface ContentUnderstandingDefaults {
    modelDeployments: Record<string, string>;
}

// @public
export type ContinuablePage<TElement, TPage = TElement[]> = TPage & {
    continuationToken?: string;
};

// @public
export interface CopyAuthorization {
    expiresAt: Date;
    source: string;
    targetAzureResourceId: string;
}

// @public
export interface DateField extends ContentField {
    type: "date";
    valueDate?: string;
}

// @public
export interface DetectedPerson {
    confidence?: number;
    personId?: string;
    source?: string;
}

// @public
export interface DocumentAnnotation {
    author?: string;
    comments?: DocumentAnnotationComment[];
    createdAt?: Date;
    id: string;
    kind: DocumentAnnotationKind;
    lastModifiedAt?: Date;
    source?: string;
    spans?: ContentSpan[];
    tags?: string[];
}

// @public
export interface DocumentAnnotationComment {
    author?: string;
    createdAt?: Date;
    lastModifiedAt?: Date;
    message: string;
    tags?: string[];
}

// @public
export type DocumentAnnotationKind = "highlight" | "strikethrough" | "underline" | "italic" | "bold" | "circle" | "note";

// @public
export interface DocumentBarcode {
    confidence?: number;
    kind: DocumentBarcodeKind;
    source?: string;
    span?: ContentSpan;
    value: string;
}

// @public
export type DocumentBarcodeKind = "QRCode" | "PDF417" | "UPCA" | "UPCE" | "Code39" | "Code128" | "EAN8" | "EAN13" | "DataBar" | "Code93" | "Codabar" | "DataBarExpanded" | "ITF" | "MicroQRCode" | "Aztec" | "DataMatrix" | "MaxiCode";

// @public
export interface DocumentCaption {
    content: string;
    elements?: string[];
    source?: string;
    span?: ContentSpan;
}

// @public
export interface DocumentChartFigure extends DocumentFigure {
    content: any;
    kind: "chart";
}

// @public
export interface DocumentContent extends MediaContent {
    annotations?: DocumentAnnotation[];
    endPageNumber: number;
    figures?: DocumentFigureUnion[];
    hyperlinks?: DocumentHyperlink[];
    kind: "document";
    pages?: DocumentPage[];
    paragraphs?: DocumentParagraph[];
    persons?: DetectedPerson[];
    sections?: DocumentSection[];
    segments?: DocumentContentSegment[];
    startPageNumber: number;
    tables?: DocumentTable[];
    unit?: LengthUnit;
}

// @public
export interface DocumentContentSegment {
    category: string;
    endPageNumber: number;
    segmentId: string;
    span: ContentSpan;
    startPageNumber: number;
}

// @public
export interface DocumentFigure {
    caption?: DocumentCaption;
    description?: string;
    elements?: string[];
    footnotes?: DocumentFootnote[];
    id: string;
    kind: DocumentFigureKind;
    role?: SemanticRole;
    source?: string;
    span?: ContentSpan;
}

// @public
export type DocumentFigureKind = "unknown" | "chart" | "mermaid";

// @public
export type DocumentFigureUnion = DocumentChartFigure | DocumentMermaidFigure | DocumentFigure;

// @public
export interface DocumentFootnote {
    content: string;
    elements?: string[];
    source?: string;
    span?: ContentSpan;
}

// @public
export interface DocumentFormula {
    confidence?: number;
    kind: DocumentFormulaKind;
    source?: string;
    span?: ContentSpan;
    value: string;
}

// @public
export type DocumentFormulaKind = "inline" | "display";

// @public
export interface DocumentHyperlink {
    content: string;
    source?: string;
    span?: ContentSpan;
    url: string;
}

// @public
export interface DocumentLine {
    content: string;
    source?: string;
    span?: ContentSpan;
}

// @public
export interface DocumentMermaidFigure extends DocumentFigure {
    content: string;
    kind: "mermaid";
}

// @public
export interface DocumentPage {
    angle?: number;
    barcodes?: DocumentBarcode[];
    formulas?: DocumentFormula[];
    height?: number;
    lines?: DocumentLine[];
    pageNumber: number;
    spans?: ContentSpan[];
    width?: number;
    words?: DocumentWord[];
}

// @public
export interface DocumentParagraph {
    content: string;
    role?: SemanticRole;
    source?: string;
    span?: ContentSpan;
}

// @public
export interface DocumentSection {
    elements?: string[];
    span?: ContentSpan;
}

// @public
export interface DocumentTable {
    caption?: DocumentCaption;
    cells: DocumentTableCell[];
    columnCount: number;
    footnotes?: DocumentFootnote[];
    role?: SemanticRole;
    rowCount: number;
    source?: string;
    span?: ContentSpan;
}

// @public
export interface DocumentTableCell {
    columnIndex: number;
    columnSpan?: number;
    content: string;
    elements?: string[];
    kind?: DocumentTableCellKind;
    rowIndex: number;
    rowSpan?: number;
    source?: string;
    span?: ContentSpan;
}

// @public
export type DocumentTableCellKind = "content" | "rowHeader" | "columnHeader" | "stubHead" | "description";

// @public
export interface DocumentWord {
    confidence?: number;
    content: string;
    source?: string;
    span?: ContentSpan;
}

// @public
export type GenerationMethod = "generate" | "extract" | "classify";

// @public
export interface IntegerField extends ContentField {
    type: "integer";
    valueInteger?: number;
}

// @public
export interface JsonField extends ContentField {
    type: "json";
    valueJson?: any;
}

// @public
export interface KnowledgeSource {
    kind: KnowledgeSourceKind;
}

// @public
export type KnowledgeSourceKind = "labeledData";

// @public
export type KnowledgeSourceUnion = LabeledDataKnowledgeSource | KnowledgeSource;

// @public
export enum KnownVersions {
    V20251101 = "2025-11-01"
}

// @public
export interface LabeledDataKnowledgeSource extends KnowledgeSource {
    containerUrl: string;
    fileListPath: string;
    kind: "labeledData";
    prefix?: string;
}

// @public
export type LengthUnit = "pixel" | "inch";

// @public
export interface MediaContent {
    analyzerId?: string;
    category?: string;
    fields?: Record<string, ContentFieldUnion>;
    kind: MediaContentKind;
    markdown?: string;
    mimeType: string;
    path?: string;
}

// @public
export type MediaContentKind = "document" | "audioVisual";

// @public
export type MediaContentUnion = DocumentContent | AudioVisualContent | MediaContent;

// @public
export interface NumberField extends ContentField {
    type: "number";
    valueNumber?: number;
}

// @public
export interface ObjectField extends ContentField {
    type: "object";
    valueObject?: Record<string, ContentFieldUnion>;
}

// @public
export type OperationState = "NotStarted" | "Running" | "Succeeded" | "Failed" | "Canceled";

// @public
export interface PagedAsyncIterableIterator<TElement, TPage = TElement[], TPageSettings extends PageSettings = PageSettings> {
    [Symbol.asyncIterator](): PagedAsyncIterableIterator<TElement, TPage, TPageSettings>;
    byPage: (settings?: TPageSettings) => AsyncIterableIterator<ContinuablePage<TElement, TPage>>;
    next(): Promise<IteratorResult<TElement>>;
}

// @public
export interface PageSettings {
    continuationToken?: string;
}

// @public
export type ProcessingLocation = "geography" | "dataZone" | "global";

// @public
export type ResourceStatus = "creating" | "ready" | "deleting" | "failed";

// @public
export function restorePoller<TResponse extends PathUncheckedResponse, TResult>(client: ContentUnderstandingClient, serializedState: string, sourceOperation: (...args: any[]) => PollerLike<OperationState_2<TResult>, TResult>, options?: RestorePollerOptions<TResult>): PollerLike<OperationState_2<TResult>, TResult>;

// @public (undocumented)
export interface RestorePollerOptions<TResult, TResponse extends PathUncheckedResponse = PathUncheckedResponse> extends OperationOptions {
    abortSignal?: AbortSignalLike;
    processResponseBody?: (result: TResponse) => Promise<TResult>;
    updateIntervalInMs?: number;
}

// @public
export type SemanticRole = "pageHeader" | "pageFooter" | "pageNumber" | "title" | "sectionHeading" | "footnote" | "formulaBlock";

// @public
export type StringEncoding = "codePoint" | "utf16" | "utf8";

// @public
export interface StringField extends ContentField {
    type: "string";
    valueString?: string;
}

// @public
export interface SupportedModels {
    completion: Record<string, string>;
    embedding: Record<string, string>;
}

// @public
export type TableFormat = "html" | "markdown";

// @public
export interface TimeField extends ContentField {
    type: "time";
    valueTime?: string;
}

// @public
export interface TranscriptPhrase {
    confidence?: number;
    endTimeMs: number;
    locale?: string;
    span?: ContentSpan;
    speaker?: string;
    startTimeMs: number;
    text: string;
    words: TranscriptWord[];
}

// @public
export interface TranscriptWord {
    endTimeMs: number;
    span?: ContentSpan;
    startTimeMs: number;
    text: string;
}

// @public
export interface UsageDetails {
    audioHours?: number;
    contextualizationTokens?: number;
    documentPagesBasic?: number;
    documentPagesMinimal?: number;
    documentPagesStandard?: number;
    tokens?: Record<string, number>;
    videoHours?: number;
}

// (No @packageDocumentation comment for this package)

```
